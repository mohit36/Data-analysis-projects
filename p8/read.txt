ğŸ”¹ Block 6 â€“ Replace the post-processing part of summarize
1. Find the OLD block

In summarize, scroll down to the part after youâ€™ve already:

validated the query

obtained sid = request.state.session_id

done IP / country detection

run hybrid_query_search(...) and have results and raw_answer

Right after that, in your screenshots, you have stuff like:

parsed_json = extract_last_json_object(raw_answer)

# Add user query to session history
await push_user(sid, query)

# Step 3: If parsed JSON contains contact info, map it to the session
if parsed_json and "contact" in parsed_json:
    service_mapping_store.setdefault(sid, {})
    service_mapping_store[sid]["contact"] = parsed_json["contact"]
    logger.info("Contact information added to session mapping for sid=%s", sid)

# Step 4: Store the assistant response along with parsed JSON
if parsed_json:
    service_mapping_store.setdefault(sid, {})
    service_mapping_store[sid].update(parsed_json)
    await push_assistant_sanitized(sid, raw_answer, parsed_json=parsed_json)
else:
    await push_assistant_sanitized(sid, raw_answer, parsed_json=None)

# ---- then more â€œensure contact in historyâ€, len(get_session_deque(sid)) checks,
# JSON merging, rebuilding raw_answer, extracting useful links, final return, etc.


Youâ€™re going to delete everything from parsed_json = extract_last_json_object(raw_answer) down to the final return { "raw_answer": ..., "useful_links": ... }.

2. Replace with this NEW block

Paste this in its place (indent to match inside summarize):

    # --------------------------------------------------
    # Post-processing: JSON, mapping, history, contact nudge
    # --------------------------------------------------

    # Try to parse the last JSON object from the answer (relevant services, etc.)
    parsed_json = extract_last_json_object(raw_answer)

    # 1) Persist user message to DB
    await push_user(sid, query)

    # 2) Update mapping store if JSON already has contact payload
    if isinstance(parsed_json, dict) and "contact" in parsed_json:
        service_mapping_store.setdefault(sid, {})
        service_mapping_store[sid]["contact"] = parsed_json["contact"]
        logger.info(
            "Contact information found in JSON for sid=%s", sid,
            extra={"service": "api"}
        )

    # 3) Persist assistant message to DB (text only)
    await push_assistant_sanitized(sid, raw_answer, parsed_json=parsed_json)

    # 4) Get up-to-date message count from DB (user + assistant included)
    msg_count = await get_msg_count(sid)

    # 5) Contact nudge logic: only after enough turns AND if contact not already present
    if msg_count > 4:  # threshold: adjust if you want
        needs_contact = not (isinstance(parsed_json, dict) and "contact" in parsed_json)

        if needs_contact:
            contact_payload = {
                "contact": "How can I contact Exigotech sales team?"
            }

            # Ensure we have a dict to work with
            if not isinstance(parsed_json, dict):
                parsed_json = {}

            parsed_json.update(contact_payload)

            # Update mapping store as well
            service_mapping_store.setdefault(sid, {})
            service_mapping_store[sid]["contact"] = parsed_json["contact"]

            logger.info(
                "Injected contact payload for sid=%s (msg_count=%s)",
                sid,
                msg_count,
                extra={"service": "api"},
            )

            # Rebuild raw_answer so the updated JSON is reflected in the text
            try:
                # Common pattern: "... \n\nrelevant services:\n{json}"
                parts = raw_answer.split("relevant services:")
                prefix = parts[0].rstrip()
                raw_answer = (
                    f"{prefix}\n\nrelevant services:\n"
                    f"{json.dumps(parsed_json, ensure_ascii=False)}"
                )
            except Exception:
                # Fallback: append JSON at the end
                raw_answer = (
                    f"{raw_answer.rstrip()}\n\nrelevant services:\n"
                    f"{json.dumps(parsed_json, ensure_ascii=False)}"
                )

    # 6) Extract useful links from results
    result_urls = _extract_result_urls(results)
    useful_links = list(result_urls)[:5]

    # 7) Final response
    return {
        "raw_answer": raw_answer,
        "useful_links": useful_links,
    }


What this does:

Single place where history is written â†’ push_user, push_assistant_sanitized â†’ Postgres.

msg_count comes from DB, not RAM.

Contact JSON injection is done once, cleanly, when:

there are enough messages (msg_count > 4), and

there is no "contact" key already.

service_mapping_store[sid]["contact"] is always updated whenever contact is present (either from the model or injected).

raw_answer is rebuilt consistently so your frontend still sees the "relevant services:\n{...json...}" pattern it already depends on.

Links are extracted at the end, no duplicate logic.

What you do now

In summarize, delete from parsed_json = extract_last_json_object(raw_answer) down to the final return {...}.

Paste the NEW block above in that spot.

Save, run the app.

Do a short manual test:

Hit /summarize 1â€“2 times â†’ confirm no contact button yet.

Hit it enough times to exceed the msg_count > 4 threshold â†’ confirm the contact option JSON appears and mapping still works.

Check chat_history table â†’ user + assistant rows are stored.

When thatâ€™s done and working, say â€œnextâ€ again and weâ€™ll tackle the next cleanup (e.g., trimming any now-dead helper functions and tightening the mapping logic).
