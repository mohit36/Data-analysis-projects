Perfect, let‚Äôs wire the **session reset** properly first, then we‚Äôll attack `prompts.py`.

I‚Äôll give you **small, surgical patches** you can drop in.

---

## 1Ô∏è‚É£ Add `clear_session_history` in `session_memory_pgvector.py`

Open:
`pgvector_helper/session_memory_pgvector.py`

Right now you already have things like:

```python
async def save_message(...):
    ...

async def get_recent_history(...):
    ...

async def get_msg_count(...):
    ...
```

üëâ **Add this new function at the bottom** (and adapt the DB bits to your setup):

```python
# pgvector_helper/session_memory_pgvector.py

async def clear_session_history(session_id: str) -> None:
    """
    Delete all stored messages for a given session.
    Used when a conversation is logically 'ended',
    e.g., after completing a contact flow or when user resets the chat.
    """
    if not session_id:
        return

    # üîß Replace this with your actual DB access logic.
    # Example if you're using asyncpg directly:
    #
    # conn = await get_pg_connection()
    # async with conn.transaction():
    #     await conn.execute("DELETE FROM chat_history WHERE session_id = $1", session_id)
    #
    # Or if you have a helper/Repository, call that instead.

    try:
        from pgvector_helper.db_connection import get_pg_connection  # if you have something like this

        conn = await get_pg_connection()
        async with conn.transaction():
            await conn.execute(
                "DELETE FROM chat_history WHERE session_id = $1",
                session_id,
            )
    except Exception as e:
        # Don't let this crash the API ‚Äì log and move on
        import logging

        logging.getLogger(__name__).warning(
            "Failed to clear session history for %s: %s", session_id, e
        )
```

‚ö†Ô∏è **Important:**
You *must* replace the `get_pg_connection` / SQL with whatever you already use to talk to Postgres. The shape is just an example.

---

## 2Ô∏è‚É£ Add `reset_session_state` helper in `chatbot_api.py`

In `chatbot_api.py`, you already import:

```python
from pgvector_helper.session_memory_pgvector import (
    save_message,
    get_recent_history,
    get_msg_count,
)
```

üëâ Change this import to also include the new function:

```python
from pgvector_helper.session_memory_pgvector import (
    save_message,
    get_recent_history,
    get_msg_count,
    clear_session_history,  # <--- add this
)
```

Then, somewhere near your other helpers (after `service_mapping_store` + `get_session_state` is a good spot), add:

```python
async def reset_session_state(sid: str) -> None:
    """
    Hard reset for a session:
    - Clear DB-backed history (Postgres)
    - Clear in-memory mapping of buttons / related services
    """
    if not sid:
        return

    # Clear per-session mapping for related-services / buttons
    service_mapping_store.pop(sid, None)

    # Clear DB history so future queries start "fresh"
    await clear_session_history(sid)
```

Now you have a clean ‚Äúkill switch‚Äù for a conversation.

---

## 3Ô∏è‚É£ Call it in the **contact YES branch**

You already have the contact follow-up flow wired roughly like:

* Detect if last assistant message was a contact offer
* Classify user reply with `classify_contact_reply` / `llm_contact_reply_classifier`
* If label == `"YES"` ‚Üí build contact query, run RAG, call `generate_exigotech_answer(intent="contact")`, return contact info.

Inside that **YES branch**, after you‚Äôve generated the contact answer and before you `return`, call `reset_session_state(sid)` and expose that to the frontend.

Here‚Äôs a generic pattern you can adapt into your existing YES branch:

```python
if label == "YES":
    # 1) Prefer explicit service name if available
    service_name = state.get("last_service_name")
    if service_name:
        query = f"How can I contact {os.getenv('COMPANY_NAME', 'Exigotech')} sales team about {service_name}?"
    else:
        query = f"How can I contact {os.getenv('COMPANY_NAME', 'Exigotech')} sales team about this service?"

    # 2) Run RAG contact search
    session_history_snapshot = await get_history_snapshot(sid)
    processed_query, results, search_metadata = await hybrid_query_search(
        query=query,
        history=session_history_snapshot,
        top_k=5,
        request_url=str(request.url),
        country_code=country_code,
    )

    contact_answer = await generate_exigotech_answer(
        chunks=results[:5],
        query=processed_query,
        links=None,
        intent="contact",
    )

    # 3) Persist final contact answer for this conversation segment
    await push_user(sid, payload.query)
    await push_assistant_sanitized(sid, contact_answer)

    # 4) Extract useful links if you want
    result_urls = _extract_result_urls(results)
    useful_links = list(result_urls)[:5]

    # 5) üî• HARD RESET SESSION CONTEXT (but keep chat visible in UI)
    await reset_session_state(sid)

    # 6) Let frontend know this conversation is "closed"
    return {
        "summary": contact_answer,
        "useful_links": useful_links,
        "mapped_questions": {},   # no more buttons after hard contact
        "needs_clarification": False,
        "session_reset": True,    # <--- frontend can use this
    }
```

You don‚Äôt have to copy this whole block if your YES branch is already there ‚Äì just:

* Make sure `await reset_session_state(sid)` is called near the end.
* Add `"session_reset": True` to the returned JSON shape for that path.

The key idea:

* History + mappings get cleared in backend,
* The user **still sees the entire conversation in UI**,
* Next user message is logically a *brand new* topic.

---

## 4Ô∏è‚É£ What your frontend should do with `session_reset`

Once this is in place, your API will sometimes return:

```json
{
  "summary": "...",
  "useful_links": [...],
  "mapped_questions": {},
  "needs_clarification": false,
  "session_reset": true
}
```

Your UI can then:

* Show a small system message like:

  > ‚Äú‚úÖ This conversation has been completed. You can start a new topic now.‚Äù
* Maybe visually separate with a divider or ‚ÄúNew conversation‚Äù chip.
* But **do not wipe** the old bubbles ‚Äî just treat future queries as fresh (backend already does that).

You get **ChatBot.com behavior**:
‚Äì old chat visible,
‚Äì new topic = fresh mental state.

---

Once you‚Äôve wired this and it compiles, we‚Äôll jump to the fun part next:
**cleaning and optimizing `prompts.py` for speed, cost, and strict Exigotech-only knowledge.**

When you‚Äôre ready, paste your current `prompts.py` (or the main prompt definitions), and I‚Äôll start cutting, tightening, and adding the env-driven `{COMPANY_NAME}` pattern you asked for.



Perfect ‚Äî I see the **exact code block** you pasted from my instructions, and yes, there is **ONE CRITICAL FIX** you must apply immediately:

---

# ‚úÖ **Your bug: `reset_session(sid)` does NOT exist**

You must rename it to the actual function name we created:

### ‚úî Correct function name:

```python
await reset_session_state(sid)
```

You currently have:

```python
await reset_session(sid)
```

This will raise:

```
NameError: reset_session is not defined
```

So update **only that line**:

---

# ‚úÖ **Patch (drop-in fix)**

Find this block:

```python
# 5) Reset session completely
await reset_session(sid)
```

Replace with:

```python
# 5) Reset session completely
await reset_session_state(sid)
```

---

# üîç **Double-check: Did you import it correctly?**

At the top of `chatbot_api.py`, you must have:

```python
from pgvector_helper.session_memory_pgvector import (
    save_message,
    get_recent_history,
    get_msg_count,
    clear_session_history,
)
```

And also:

```python
async def reset_session_state(sid: str) -> None:
    ...
```

If all that is in place, this branch will now work perfectly.

---

# üß† **Why this matters**

Without this fix:

* YES ‚Üí contact flow works
* but backend crashes at reset step
* frontend gets no JSON
* chat appears frozen or dies

After the fix:

* The contact flow completes
* History is cleared
* UI shows previous chat
* New message = new session context

Exactly like ChatBot.com.

---

# üìå Quick checklist before we move to `prompts.py`

### Must be true before next step:

| Item                                               | Status              |
| -------------------------------------------------- | ------------------- |
| `reset_session_state` exists                       | ‚úÖ                   |
| `clear_session_history` implemented in PG helper   | ‚úÖ                   |
| Correct import in chatbot_api                      | ‚ö† verify            |
| Contact YES branch uses `reset_session_state(sid)` | ‚¨Ö apply the fix     |
| JSON returns `session_reset` or `session_ended`    | You already do this |

---

# üöÄ After this fix, you can send me `prompts.py`

And then:

* I will optimize each prompt
* Remove redundant instructions
* Make everything env-driven (`COMPANY_NAME`)
* Reduce token cost
* Improve consistency
* Add safe fallbacks
* Add caching strategies (per prompt)
* Ensure fast models can handle lightweight prompts

Your bot will become **fast like ChatBot.com but far more accurate**.

---

üí¨ **Send `prompts.py` now and I‚Äôll refactor it.**







Good, this is *exactly* the stage where cleaning up pays off in speed and cost. Let‚Äôs be ruthless but sensible, not just delete things randomly.

I‚Äôll break it into two parts:

1. **What to keep / delete / merge in `prompt_list.py` right now**
2. **Concrete short versions for the heavy prompts (patches you can paste)**

---

## 1Ô∏è‚É£ What to keep vs delete / merge

From your screenshots I can see these major prompt blocks in `prompt_list.py`:

### A. Intent classification

You currently have **two** intent classifiers:

1. `intent_classification_prompt`
2. `main_intent_classifier`
   (with the comment `#currently using this one`)

**Decision:**

* ‚úÖ **KEEP:** `main_intent_classifier`
* ‚ùå **DELETE:** `intent_classification_prompt`

They do the same job with slightly different wording. Two separate big prompts = more confusion and wasted tokens. Your code should only ever call **one** classifier.

Action for you:

* In the whole repo, search for `intent_classification_prompt`.

  * If nothing uses it ‚Üí delete that whole block from `prompt_list.py`.
  * If something still uses it ‚Üí change that usage to `main_intent_classifier`, then delete the old one.

---

### B. Query type classification

* `query_type_classification_prompt`
  (classifies into `standalone`, `follow_up`, `under_specified`)

**Decision:**

* ‚úÖ **KEEP, but shorten** ‚Äì this one is important for your ‚Äúunder-specified ‚Üí clarification‚Äù logic.
* We will trim the text and keep only:

  * 1‚Äì2 bullet rules for each type
  * 2‚Äì3 short examples
  * a strict ‚Äúreturn ONLY this label‚Äù instruction.

Patch is below in section 2.

---

### C. Decontextualization

* `query_decontextualization_prompt`
  (rewrites using history, expands abbreviations, etc.)

**Decision:**

* ‚úÖ **KEEP, but shorten.**
  The *behaviour* is correct for your architecture:

  * use history only when needed;
  * expand abbreviations (MD ‚Üí Managing Director, etc.);
  * keep query standalone.

We‚Äôll compress wording + examples to reduce tokens but not logic.

---

### D. Clarification prompts

You have:

* `clarification_underspecified_prompt`
* `clarification_followup_prompt`

**Decision:**

* ‚úÖ **KEEP both, but simplify.**
  They map nicely to your ‚Äúquery_type = under_specified‚Äù and ‚Äúquery_type = follow_up but missing context‚Äù paths.

What we do:

* Keep *one* clear example block per prompt.
* Shorten instructions + remove redundant sentences.

---

### E. Greeting / conclusion / page / case / contact / about / career prompts

From earlier:

* `greeting_response_prompt`
* `conclusion_response_prompt`
* `contact_intent_prompt`
* `about_intent_prompt`
* `career_intent_prompt`
* `page_intent_prompt` / `page_intent_prompt_improved`
* `case_intent_prompt`

**Decision:**

* ‚úÖ **KEEP only the versions you actually call from `exigotech_chatbot.py`.**
* ‚ùå **Delete older duplicates.**

Concretely:

1. Open `exigotech_chatbot.py`.

2. At top you import:

   ```python
   from prompt_list import (
       greeting_response_prompt,
       conclusion_response_prompt,
       contact_intent_prompt,
       about_intent_prompt,
       career_intent_prompt,
       page_intent_prompt,
       case_intent_prompt,
       page_intent_prompt_improved,
   )
   ```

3. Inside `run_exigotech_prompt`, you currently pick the prompt based on `intent`.
   **Keep only those prompt variables that are imported + used in that function.**

4. Anything in `prompt_list.py` that isn‚Äôt:

   * imported anywhere, **and**
   * not referenced in any `.py` file
     ‚Üí safe to delete.

So: run ‚ÄúFind in Files‚Äù in VS Code for each prompt name. If count = 1 (definition only), delete it.

---

## 2Ô∏è‚É£ Shorter, cheaper versions of the heavy prompts

Here are replacement blocks you can paste directly into `prompt_list.py`
(overwrite the existing ones).

### 2.1 `main_intent_classifier` (single intent classifier)

```python
main_intent_classifier = """
You are a query intent classifier for the Exigotech chatbot.

Classify the user query into EXACTLY ONE of these intents:
- greeting
- conclusion
- contact        (pricing, quotes, licenses, renewals, purchases, support/help, how to reach company or sales)
- about          (people, roles, leadership, org structure, careers at company)
- career         (jobs, hiring, recruitment, positions)
- page           (services, capabilities, topics, blogs, articles, general info about offerings)
- case           (case studies, success stories, testimonials)

Rules (short):

1) greeting
   - Only if it‚Äôs JUST a greeting (‚Äúhi‚Äù, ‚Äúhello‚Äù, ‚Äúhey‚Äù).
   - If greeting + question ‚Üí classify by the question, NOT greeting.

2) conclusion
   - Only if clearly ending the chat (‚Äúbye‚Äù, ‚Äúthank you, bye‚Äù, ‚Äúthat‚Äôs all, thanks‚Äù).

3) contact
   - Only when user asks about contact information, sales team, support team, pricing, cost, quote, demo, renewal, or ‚Äútalk to a person‚Äù.
   - Example: ‚ÄúHow do I contact sales?‚Äù, ‚ÄúWhat does Exigotech charge for cloud security?‚Äù, ‚ÄúI want a demo‚Äù.

4) about
   - Questions about people or org: CEO, leadership, team, roles, departments, company background.
   - Example: ‚ÄúWho is in sales team?‚Äù, ‚ÄúWho is the CEO?‚Äù, ‚ÄúTell me about the leadership team‚Äù.

5) career
   - Jobs, openings, applying, hiring, recruitment.
   - Example: ‚ÄúAny software engineer jobs?‚Äù, ‚ÄúHow can I apply?‚Äù.

6) page
   - General info about services/solutions, topics, offerings, blogs, articles.
   - Example: ‚ÄúWhat services does Exigotech provide?‚Äù, ‚ÄúShow me your AI services‚Äù.

7) case
   - Case studies, success stories, client stories, testimonials.
   - Example: ‚ÄúShow me cloud security success stories‚Äù.

Disambiguation:
- If query is about prices/support/contact ‚Üí contact.
- If query is about people / roles / org ‚Üí about.
- If query is about services or solutions, not price/support ‚Üí page.

Return ONLY one word:
greeting, conclusion, contact, about, career, page, or case.
No quotes or extra text.
"""
```

Delete the old `intent_classification_prompt` block entirely.

---

### 2.2 `query_type_classification_prompt`

```python
query_type_classification_prompt = """
You are a query type analyzer for the Exigotech chatbot.

Classify the user query into EXACTLY ONE type:

1) "standalone"
   - Complete on its own, with clear subject.
   - Does NOT depend on previous conversation.
   - Examples:
     - "Who is the CEO of Exigotech?"
     - "What cloud services does Exigotech offer?"
     - "Show me case studies about AI solutions."

2) "follow_up"
   - Refers to previous conversation using pronouns or vague references.
   - Needs recent history to understand.
   - Examples:
     - "How old is he?" (after asking about a person)
     - "What‚Äôs the pricing for it?" (after a service was mentioned)
     - "Can you explain this in detail?" (refers to previous topic).

3) "under_specified"
   - Too vague or missing key details.
   - Not clearly tied to history (no pronouns).
   - Hard to answer without asking for more info.
   - Examples:
     - "How much does it cost?" (no service specified, no history reference)
     - "Tell me more" (no topic)
     - "What are the features?" (no product/service specified).

Classification rules:
- If query uses pronouns (he/she/it/they/that/this) or ‚Äúthis/that one‚Äù ‚Üí **follow_up**.
- Else if query is complete and specific ‚Üí **standalone**.
- Else ‚Üí **under_specified**.

Return ONLY one word:
standalone, follow_up, or under_specified.
No explanations or extra text.
"""
```

---

### 2.3 `query_decontextualization_prompt`

```python
query_decontextualization_prompt = """
You are a query decontextualizer for the Exigotech chatbot.

Your job: rewrite the user‚Äôs query so it is STANDALONE and COMPLETE,
using only the provided conversation history.

Rules:
1) Replace pronouns (he/she/it/they/that/this) with the correct person, service, or topic from history.
2) Add missing context (service names, product names, roles, topics) so the query makes sense alone.
3) Expand abbreviations and short forms (e.g., MD ‚Üí Managing Director, CEO ‚Üí Chief Executive Officer).
4) Keep the query short, natural, and in the user‚Äôs voice.
5) Preserve the user‚Äôs intent exactly. Do NOT add new facts.

History (user + assistant turns):
{history}

Original user query:
{query}

Return ONLY the rewritten query text, nothing else.
"""
```

---

### 2.4 Clarification prompts

#### `clarification_underspecified_prompt`

```python
clarification_underspecified_prompt = """
The user asked: "{query}"

This query is too vague or incomplete. Generate ONE short, polite
clarifying question so you can understand what they need.

Examples:
- Query: "How much does it cost?"
  Clarification: "Which Exigotech service or product are you asking about for pricing?"
- Query: "Tell me more"
  Clarification: "What would you like to know more about? A specific service, solution, or case study?"
- Query: "What are the features?"
  Clarification: "Which product or service do you want to know the features of?"

Now generate a helpful clarifying question for this user.
Return ONLY the question text.
"""
```

#### `clarification_followup_prompt`

```python
clarification_followup_prompt = """
The user asked: "{query}"

This looks like a follow-up that depends on earlier conversation,
but you do NOT have that context available.

Generate ONE short, polite question asking the user to restate
or specify what they are referring to.

Examples:
- Query: "How old is he?"
  Clarification: "Who are you asking about? Please specify the person's name."
- Query: "What‚Äôs the pricing for that?"
  Clarification: "Which Exigotech service or solution are you asking about for pricing?"
- Query: "Can you explain this in detail?"
  Clarification: "Could you specify which topic or service you‚Äôd like a detailed explanation for?"

Return ONLY the clarifying question text.
"""
```

---

## 3Ô∏è‚É£ What I recommend you actually do now

Very concrete steps for you:

1. **Clean duplicates**

   * Delete `intent_classification_prompt`.
   * Delete any other prompt definitions that are not referenced anywhere (search in VS Code).

2. **Replace** the existing long blocks for:

   * `main_intent_classifier`
   * `query_type_classification_prompt`
   * `query_decontextualization_prompt`
   * `clarification_underspecified_prompt`
   * `clarification_followup_prompt`
     with the versions above.

3. **Don‚Äôt touch** your greeting/about/contact/page/case prompts yet.
   We‚Äôll optimize those after we see real traces and costs.

4. **Later step (after this works):**

   * Introduce `{COMPANY_NAME}` style placeholders (or simple `.format(company_name=...)`) so we can flip from Exigotech ‚Üí some other company without rewriting prompts.

If you paste these in and everything runs, next I can help you:

* trim the **answer-generation / ‚Äúrelevant services‚Äù** prompts in `exigotech_chatbot.py`, and
* tighten them so they **never** go outside your context (no OpenAI-CEO style answers) while still being short.




