async def search_internal_answers_async(
    client_conn,
    query_text: str,
    query_vector: list[float],
    top_k: int = 10,
    use_reranking: bool = False,
):
    loop = asyncio.get_running_loop()
    cursor = client_conn.cursor(cursor_factory=DictCursor)

    collection_name = "cached_question_answer"

    base_sql = f"""
        SELECT 
            id,
            question,
            answer_text,
            frequency,
            1 - (vector <=> %s::vector) AS score
        FROM {collection_name}
        ORDER BY vector <=> %s::vector
        LIMIT %s;
    """
    params = (query_vector, query_vector, top_k)

    rows = await loop.run_in_executor(
        None,
        lambda: (cursor.execute(base_sql, params), cursor.fetchall())[1],
    )

    results = []
    for row in rows:
        results.append({
            # core fields your pipeline expects
            "id": row["id"],                     # internal DB id
            "url": None,                         # no public URL
            "page_title": row["question"],       # treat the question as title
            "text": row["answer_text"],          # reranker uses this
            "source_type": "internal",           # distinguish later
            "chunk_index": 0,                    # single chunk

            # extra metadata (optional)
            "score": float(row["score"]),
            "frequency": row["frequency"],
        })

    return results
def _merge_and_dedup_candidates(self, *result_lists):
    all_results = []
    for lst in result_lists:
        if lst:
            all_results.extend(lst)

    dedup = {}

    for r in all_results:
        # Website chunks have URL; internal answers don't
        if r.get("url"):
            key = r["url"]
        else:
            # internal answers â€“ use DB id or fallback to question
            internal_id = r.get("id") or r.get("page_title")
            key = f"internal://{internal_id}"

        score = float(r.get("score", 0.0))

        if key not in dedup or score > dedup[key]["score"]:
            dedup[key] = r

    return sorted(dedup.values(), key=lambda x: x.get("score", 0.0), reverse=True)
