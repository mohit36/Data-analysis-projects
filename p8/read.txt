@app.post("/summarize")
async def summarize(payload: SummarizeRequest, request: Request) -> Dict[str, Any]:
    try:
        # 0) Basic validation
        query = payload.query.strip()
        if not query:
            return JSONResponse(
                status_code=400,
                content={"error": "query is required"},
            )

        # 1) Session handling
        sid = getattr(request.state, "session_id", None)
        if not sid:
            sid = str(uuid.uuid4())
            logger.warning(
                "No session_id found on request.state; generated fallback sid=%s",
                sid,
                extra={"service": "api"},
            )

        logger.info(
            "summarize called with sid=%s",
            sid,
            extra={"service": "api"},
        )

        # 2) DB-based message count (used later for contact nudge)
        msg_count = await get_msg_count(sid)

        # 3) Lookup for mapped query (e.g., contact mapping)
        mapped_question = lookup_mapped_question(sid, query)
        if mapped_question:
            logger.info("Phase B mapping hit: %s -> %s", query, mapped_question)
            query = mapped_question  # use mapped query
            # DO NOT reset service_mapping_store here â€“ it now holds contact state

        # 4) IP / geo info
        client_ip, override_country = get_client_ip(request)
        client = getattr(request.app.state, "httpx_client", None)
        country_code = override_country
        if not country_code and client:
            country_code = await get_country_code(client_ip, client)

        location = await get_location_from_ip(client_ip, client) if client else "Unknown"
        logger.info(
            "Query received | sid=%s | IP=%s | Location=%s",
            sid,
            client_ip,
            location,
        )

        # 5) First-pass intent classification
        agent = SearchAgent()
        query_intent = await agent.classify_query_type(query)
        logger.info("Query intent classified: %s", query_intent)

        # 6) Contact / lead capture flow (email + phone) with state
        detected_email = extract_email(query)
        detected_phone = extract_phone(query)

        # update per-session contact state
        contact_state = update_contact_state(sid, detected_email, detected_phone)
        email_in_state = contact_state.get("email")
        phone_in_state = contact_state.get("phone")

        # Is this part of a "contact us" flow?
        is_contact_intent = False
        if isinstance(query_intent, str) and query_intent.lower() == "contact":
            is_contact_intent = True
        if "contact" in query.lower():
            is_contact_intent = True

        results: list[Any] = []
        raw_answer: str

        if is_contact_intent:
            # ---- Explicit contact flow: no RAG ----
            if not email_in_state:
                # 1) No email yet -> ask for email
                raw_answer = "Can you please provide your email address?"
                results = []
            elif not phone_in_state:
                # 2) Have email, no phone yet -> ask for phone
                raw_answer = (
                    f"Thank you for providing your email: {email_in_state}. "
                    "Please provide your phone number."
                )
                results = []
            else:
                # 3) Have both email and phone -> confirm and end
                raw_answer = (
                    "Thank you for providing your contact details.\n"
                    f"- Email: {email_in_state}\n"
                    f"- Phone: {phone_in_state}\n\n"
                    "Our team will contact you shortly."
                )
                results = []

        else:
            # ---- Normal RAG / search flow ----
            session_history_snapshot = await get_history_snapshot(sid)

            # your existing hybrid_query_search signature:
            # (query, session_history_snapshot, top_k=10, request_url, country_code)
            query, results = await hybrid_query_search(
                query,
                session_history_snapshot,
                top_k=10,
                request_url=str(request.url),
                country_code=country_code,
            )

            if not results:
                return {
                    "raw_answer": "No results found for your query.",
                    "useful_links": [],
                }

            # Optionally re-classify intent on refined query
            query_intent = await agent.classify_query_type(query)
            logger.info("Query intent re-classified: %s", query_intent)

            # Your existing answer generator
            raw_answer = await generate_exigotech_answer(
                chunks=results[:5],
                query=query,
                intent=query_intent,
            )

        # --------------------------------------------------
        # 7) Post-processing: JSON, mapping, history, contact nudge
        # --------------------------------------------------

        # Try to parse the last JSON object from the answer (relevant services, etc.)
        parsed_json = extract_last_json_object(raw_answer)

        # 1) Persist user message to DB
        await push_user(sid, query)

        # 2) Update mapping store if JSON already has contact payload
        if isinstance(parsed_json, dict) and "contact" in parsed_json:
            service_mapping_store.setdefault(sid, {})
            service_mapping_store[sid]["contact"] = parsed_json["contact"]
            logger.info(
                "Contact information found in JSON for sid=%s",
                sid,
                extra={"service": "api"},
            )

        # 3) Persist assistant message to DB (text only)
        await push_assistant_sanitized(sid, raw_answer, parsed_json=parsed_json)

        # 4) Reload message count from DB after writing this turn
        msg_count = await get_msg_count(sid)

        # 5) Contact nudge logic: only after enough turns AND if contact not already present
        if msg_count > 4:
            needs_contact = not (
                isinstance(parsed_json, dict) and "contact" in parsed_json
            )

            if needs_contact:
                contact_payload = {
                    "contact": "How can I contact Exigotech sales team?"
                }

                # Ensure we have a dict to work with
                if not isinstance(parsed_json, dict):
                    parsed_json = {}

                parsed_json.update(contact_payload)

                # Update mapping store as well
                service_mapping_store.setdefault(sid, {})
                service_mapping_store[sid]["contact"] = parsed_json["contact"]

                logger.info(
                    "Injected contact payload for sid=%s (msg_count=%s)",
                    sid,
                    msg_count,
                    extra={"service": "api"},
                )

                # Rebuild raw_answer so the updated JSON is reflected in the text
                try:
                    # Typical pattern: "... \n\nrelevant services:\n{json}"
                    parts = raw_answer.split("relevant services:")
                    prefix = parts[0].rstrip()
                    raw_answer = (
                        f"{prefix}\n\nrelevant services:\n"
                        f"{json.dumps(parsed_json, ensure_ascii=False)}"
                    )
                except Exception:
                    # Fallback: append JSON at the end
                    raw_answer = (
                        f"{raw_answer.rstrip()}\n\nrelevant services:\n"
                        f"{json.dumps(parsed_json, ensure_ascii=False)}"
                    )

        # 6) Extract useful links from results
        result_urls = _extract_result_urls(results)
        useful_links = list(result_urls)[:5]

        # 7) Final response
        return {
            "raw_answer": raw_answer,
            "useful_links": useful_links,
        }

    except Exception as e:
        logger.exception("summarize failed: %s", e)
        return JSONResponse(
            status_code=500,
            content={"error": "Internal error"},
        )
