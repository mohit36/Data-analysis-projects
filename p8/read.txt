async def process_query_with_context(
    query: str,
    history: List[Dict[str, str]],
    relevance_threshold: float = RELEVANCE_THRESHOLD,
) -> Tuple[str, Dict[str, Any]]:
    """
    Main controller for query → (possibly rewritten query, metadata).

    Returns:
        processed_query: str (may be same as input)
        meta: {
            "needs_clarification": bool,
            "clarification_question": Optional[str],
            "query_form": "standalone|follow_up|under_specified",
        }
    """
    meta: Dict[str, Any] = {
        "needs_clarification": False,
        "clarification_question": None,
        "query_form": None,
    }

    # 1) Classify query form (standalone / follow_up / under_specified)
    query_form = await classify_query_form(query)
    meta["query_form"] = query_form

    # 1.b) SPECIAL CASE: generic “what services do you provide” style questions
    # These should NEVER go to clarification – they should be treated as
    # standalone service-overview questions and answered directly.
    #
    # We intentionally ignore intent here (pass None) so the pattern
    # matcher only looks at the text.
    if is_generic_services_question(query, intent=None):
        logger.info(
            "Detected generic services overview question – "
            "forcing query_form='standalone' and skipping clarification."
        )
        query_form = "standalone"
        meta["query_form"] = query_form

    # 2) Filter history by relevance (semantic similarity + recency)
    filtered_history = filter_history_by_relevance(
        history=history,
        query=query,
        threshold=relevance_threshold,
    )

    # 3) Under-specified → clarification only
    # (This will NOT run for generic services questions because we forced
    #  query_form to 'standalone' above.)
    if query_form == "under_specified":
        clar_q = await generate_underspecified_clarification(query)
        meta["needs_clarification"] = True
        meta["clarification_question"] = clar_q
        return query, meta

    # 4) Follow-up → needs history (if any)
    if query_form == "follow_up":
        if filtered_history:
            # Use LLM prompt that incorporates only relevant history
            rewritten = await decontextualize_query_with_history(
                query, filtered_history
            )
            return rewritten, meta
        else:
            # We *should* have history but don't – ask the user to clarify
            clar_q = await generate_followup_clarification(query)
            meta["needs_clarification"] = True
            meta["clarification_question"] = clar_q
            return query, meta

    # 5) Standalone → no history, just clean up the query
    rewritten = await rewrite_query_no_history(query)
    return rewritten, meta
