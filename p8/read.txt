Yeah, manual clicking is done. If you keep “testing by vibes”, you’ll never know if a change silently broke AU vs SG vs IN vs PH or the contact flow.

Let’s set up a semi-automated test rig you can actually run.

I’ll give you:

A tiny change in summarize so you can control country without real IPs.

A CSV format for test cases.

A Python script that:

Reads the CSV

Simulates conversations (multi-turn) per scenario

Sends a country override for AU/SG/IN/PH

Prints pass/fail for each step.

You run: python test_runner.py and watch it scream where behaviour is wrong.

1️⃣ Small change in summarize to control country (for tests)

Right now you do roughly:

client_ip, override_country = get_client_ip(request)
client = getattr(request.app.state, "http_client", None)
country_code = override_country or await get_country_code(client_ip, client) if client else None


That makes tests depend on real IP → geo API. Nasty.

Patch it so tests can override via a header.

Add this near the top of summarize, right after you get sid and log:
    # --- Country override for testing / routing ---
    # Priority:
    # 1) X-Country-Override header (tests)
    # 2) override_country from get_client_ip (if you already support it)
    # 3) Geo lookup from IP
    test_country = request.headers.get("X-Country-Override")

    client_ip, override_country = get_client_ip(request)
    client = getattr(request.app.state, "http_client", None)

    if test_country:
        country_code = test_country
    elif override_country:
        country_code = override_country
    elif client:
        country_code = await get_country_code(client_ip, client)
    else:
        country_code = None

    location = await get_location_from_ip(client_ip, client) if client else "Unknown"
    logger.info(
        "Query received | sid=%s | IP=%s | Location=%s | Country=%s | TestCountry=%s",
        sid,
        client_ip,
        location,
        country_code,
        test_country,
    )


Now your tests can force AU/SG/IN/PH without caring about IPs or geo APIs:

X-Country-Override: AU

X-Country-Override: SG

X-Country-Override: IN

X-Country-Override: PH

Your existing DB-selection logic using country_code will still work.

2️⃣ CSV format for test cases

Create a file: test_cases.csv in your project root.

Use this header:

scenario_id,step,country,query,expect_contains,expect_contact_json


scenario_id – groups multi-turn conversations (e.g. 1, 1, 1 is one flow)

step – order inside scenario (1, 2, 3…)

country – AU, SG, IN, PH (or blank if you don’t care)

query – user message

expect_contains – substring that should appear in answer (or leave empty)

expect_contact_json – true/false if you expect a "contact" key in response JSON

Example content:

scenario_id,step,country,query,expect_contains,expect_contact_json
1,1,AU,"hi","",false
1,2,AU,"what services do you offer?","service",true

2,1,AU,"I need to contact your team","provide your email",false
2,2,AU,"my email is test@mail.com","provide your phone number",false
2,3,AU,"my phone is 9876543210","contact details",false

3,1,IN,"show me case studies","case study",false
3,2,IN,"show me blogs","blog",false

4,1,SG,"hi","",false
4,2,SG,"hi","",false
4,3,SG,"hi","",false
4,4,SG,"hi","",false


You can grow this with all your “services, blogs, careers, contact” variants.

3️⃣ The semi-automated runner: test_runner.py

Create test_runner.py next to your CSV:

import csv
import requests
from collections import defaultdict

API_URL = "http://localhost:8000/summarize"  # adjust if different


def load_test_cases(csv_path: str):
    scenarios = defaultdict(list)
    with open(csv_path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            scenario_id = row["scenario_id"].strip()
            row["step"] = int(row["step"])
            scenarios[scenario_id].append(row)

    # sort steps inside each scenario
    for sid in scenarios:
        scenarios[sid].sort(key=lambda r: r["step"])
    return scenarios


def run_scenario(session: requests.Session, scenario_id: str, steps: list[dict]):
    print(f"\n===== Scenario {scenario_id} =====")
    all_passed = True

    # new session already has its own cookie jar → one sid per scenario

    for row in steps:
        country = (row.get("country") or "").strip() or None
        query = row["query"]
        expect_contains = (row.get("expect_contains") or "").strip()
        expect_contact_json = (row.get("expect_contact_json") or "").strip().lower() == "true"

        headers = {}
        if country:
            headers["X-Country-Override"] = country  # used in summarize()

        print(f"\nStep {row['step']} | Country={country or '-'}")
        print(f"User: {query}")

        resp = session.post(API_URL, json={"query": query}, headers=headers)
        try:
            resp.raise_for_status()
        except Exception as e:
            print(f"❌ HTTP error: {e} (status={resp.status_code})")
            print("Body:", resp.text[:500])
            all_passed = False
            continue

        try:
            data = resp.json()
        except Exception:
            print("❌ Response is not JSON:", resp.text[:500])
            all_passed = False
            continue

        # Your API might use "summary" or "raw_answer"
        answer = data.get("summary") or data.get("raw_answer") or ""
        contact_field = data.get("contact")

        print(f"Bot: {answer[:200].replace('\\n', ' ')}{'...' if len(answer) > 200 else ''}")
        print(f"Contact field present? {bool(contact_field)}")

        # Simple checks
        step_ok = True

        if expect_contains:
            if expect_contains.lower() not in answer.lower():
                print(f"❌ Expected answer to contain: '{expect_contains}'")
                step_ok = False
            else:
                print(f"✅ Contains expected text: '{expect_contains}'")

        if expect_contact_json is not None:
            if bool(contact_field) != expect_contact_json:
                print(
                    f"❌ Contact JSON presence mismatch. "
                    f"Expected: {expect_contact_json}, got: {bool(contact_field)}"
                )
                step_ok = False
            else:
                print(f"✅ Contact JSON presence matches expected: {expect_contact_json}")

        if step_ok:
            print("✅ Step PASSED")
        else:
            print("❌ Step FAILED")
            all_passed = False

    return all_passed


def main():
    scenarios = load_test_cases("test_cases.csv")
    overall_ok = True

    for scenario_id, steps in scenarios.items():
        # new Session per scenario → new cookie jar → new sid
        session = requests.Session()
        scenario_ok = run_scenario(session, scenario_id, steps)
        if not scenario_ok:
            overall_ok = False

    print("\n==============================")
    if overall_ok:
        print("✅ ALL SCENARIOS PASSED")
    else:
        print("❌ Some scenarios FAILED")


if __name__ == "__main__":
    main()

What this does:

Groups rows by scenario_id → each is one conversation.

Uses a new requests.Session() per scenario so cookies (and your sid) persist per flow.

For each step:

Sets X-Country-Override header based on CSV.

Calls /summarize with {"query": ...}.

Reads summary or raw_answer and contact from JSON.

Checks:

Whether expect_contains is a substring of the answer.

Whether contact key exists when expect_contact_json == true.

Prints ✅/❌ per step and per scenario.

That’s your semi-automated rig: you still design expectations, but the system drives the chat and flags mismatches.

How to use it

Apply the small X-Country-Override patch to summarize.

Create test_cases.csv with a few core scenarios:

greetings spam (no contact injection)

1–2 service queries (contact injection expected)

full contact flow (email → phone → done)

blogs/case studies (no contact stuff)

Start your FastAPI app.

Run:

python test_runner.py


Watch which steps fail. Use that to debug your intent logic, contact mode, injection, etc.

If you want, next step I can:

Generate a ready-made test_cases.csv file filled with the scenarios we discussed (services, careers, blogs, contact, AU/SG/IN/PH).
